package org.broadinstitute.gpinformatics.athena.boundary.billing;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.broadinstitute.gpinformatics.athena.control.dao.work.WorkCompleteMessageDao;
import org.broadinstitute.gpinformatics.athena.entity.work.WorkCompleteMessage;
import org.broadinstitute.gpinformatics.infrastructure.common.SessionContextUtility;

import javax.ejb.ActivationConfigProperty;
import javax.ejb.MessageDriven;
import javax.inject.Inject;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;

/**
 * A Message Driven Bean to receive JMS messages from data analysis pipelines.
 */
@SuppressWarnings("UnusedDeclaration")
@MessageDriven(name = "WorkCompleteMessageBean", activationConfig = {
        @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue") } )
public class WorkCompleteMessageBean implements MessageListener {

    /**
     * Add a true boolean property with this name when creating a message if you don't want the data to be written
     * to the persistent store.
     */
    public static final String TEST_DATA_FLAG = "MercuryTestDataOnly";

    private WorkCompleteMessageDao workCompleteMessageDao;

    private SessionContextUtility sessionContextUtility;

    private static final Log log = LogFactory.getLog(WorkCompleteMessageBean.class);

    @Inject
    public WorkCompleteMessageBean(WorkCompleteMessageDao workCompleteMessageDao,
                                   SessionContextUtility sessionContextUtility) {
        this.workCompleteMessageDao = workCompleteMessageDao;
        this.sessionContextUtility = sessionContextUtility;
    }

    public WorkCompleteMessageBean() {
    }

    @Override
    public void onMessage(final Message message) {
        sessionContextUtility.executeInContext(new SessionContextUtility.Function() {
            @Override
            public void apply() {
                processMessage(message);
            }
        });
    }

    public void processMessage(Message message) {
        try {
            // This pulls all the values out of the message.
            Map<String, Object> values = new HashMap<>();

            Enumeration<?> mapNames = message.getPropertyNames();
            while (mapNames.hasMoreElements()) {
                String name  = (String) mapNames.nextElement();
                values.put(name, message.getObjectProperty(name));
            }

            String pdoName = message.getStringProperty(WorkCompleteMessage.Properties.PDO_NAME.name());
            String aliquotId = message.getStringProperty(WorkCompleteMessage.Properties.ALIQUOT_ID.name());
            String partNumber = message.getStringProperty(WorkCompleteMessage.Properties.PART_NUMBER.name());
            Long userId = message.getLongProperty(WorkCompleteMessage.Properties.USER_ID.name());
            long completedTime = message.getLongProperty(WorkCompleteMessage.Properties.COMPLETED_TIME.name());
            Date completedDate = new Date(completedTime);

            if (StringUtils.isBlank(pdoName) || StringUtils.isBlank(aliquotId)) {
                log.error("Received a message without required parameters, cannot process: " + message);
                return;
            }

            WorkCompleteMessage workComplete =
                    new WorkCompleteMessage(pdoName, aliquotId, partNumber, completedDate, values);

            if (message.getBooleanProperty(TEST_DATA_FLAG)) {
                // Data generated by an automated test, don't write to the database.
                return;
            }

            workCompleteMessageDao.persist(workComplete);
        } catch (JMSException jmse) {
            throw new RuntimeException("Got a JMS exception processing work complete message", jmse);
        }
    }
}
