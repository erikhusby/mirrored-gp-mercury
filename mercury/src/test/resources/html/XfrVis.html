<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- This page allows Transfer Visualizer to be run on database free tests, without a web server. -->
<head>
    <title>Transfer Visualizer</title>
    <style>
        /*@import url(../style.css);*/
        .background {
            stroke: white;
            stroke-width: 1px;
            fill: white;
        }

        .node {
            stroke: black;
            stroke-width: 1.5px;
            cursor: move;
            fill: #8dedf0;
        }

        .link {
            fill: none;
            stroke: #000;
            stroke-width: 3px;
            opacity: 0.7;
            marker-end: url(#end-arrow);
        }

        .label {
            fill: black;
            font-family: Arial;
            font-size: 12px;
            text-anchor: middle;
            cursor: move;
        }

        .overlay {
            fill: LightYellow;
            pointer-events: all;
        }
    </style>
</head>
<body>
<script src="../../../../src/main/webapp/resources/scripts/d3.3.5.6.min.js"></script>
<script src="../../../../src/main/webapp/resources/scripts/dagre.min.0.7.3.js"></script>
<script>
    var width = 1200, height = 950;

    // Set up pan and zoom.
    var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .call(d3.behavior.zoom().scaleExtent([.1, 8]).on("zoom", zoom))
            .append("g");
    svg.append("rect")
            .attr("class", "overlay")
            .attr("width", width * 10)
            .attr("height", height * 10);
    function zoom() {
        svg.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
    }

    // Arrows for edges.
    svg.append('svg:defs').append('svg:marker')
            .attr({
                id: 'end-arrow',
                viewBox: '0 -5 10 10',
                refX: 8,
                markerWidth: 6,
                markerHeight: 6,
                orient: 'auto'
            })
            .append('svg:path')
            .attr({
                d: 'M0,-5L10,0L0,5L2,0',
                'stroke-width': '0px',
                fill: '#000'
            });

    d3.json("XfrVis.json", function (error, json) {

        // Create a new directed graph
        var g = new dagre.graphlib.Graph();

        // Set an object for the graph label
        g.setGraph({});

        // Default to assigning a new object as a label for each new edge.
        g.setDefaultEdgeLabel(function() { return {}; });
        // function read(json) {

        // Load json nodes and links into Dagre's model.  Dagre primarily uses width and height.
        for (i = 0; i < json.nodes.length; i++) {
            g.setNode(json.nodes[i].id, json.nodes[i].values);
        }
        for (i = 0; i < json.links.length; i++) {
            g.setEdge(json.links[i].source, json.links[i].target);
        }

        // Assign x / y coordinates.
        dagre.layout(g);

        // Render racks and plates.
        var margin = 10, pad = 12;
        var node = svg.selectAll(".node")
                .data(g.nodes())
                .enter().append("g")
                .attr("class", "node")
                .attr("transform", function (d) {
                    var graphNode = g.node(d);
                    var x = graphNode.x - (graphNode.width / 2);
                    var y = graphNode.y - (graphNode.height / 2);
                    return "translate(" + x + "," + y + ")";
                });
        node.append("rect")
                .attr("width", function (d) {
                    return g.node(d).width;
                })
                .attr("height", function (d) {
                    return g.node(d).height;
                });
        node.append("text")
                .attr("class", "label")
                .attr("dx", 25)
                .attr("dy", 10)
                .text(function (d) {
                    return g.node(d).label;
                });
//                .each(function (d) {
//                    var b = this.parentNode.getBBox();
//                    var extra = 2 * margin + 2 * pad;
//                    d.width = b.width + extra;
//                    d.height = b.height + extra;
//                });

        // Set the D3 datum to the children.
        var nodeChildEnter = node.selectAll(".nodeChild")
                .data(function (d) {
                    return g.node(d).children;
                })
                .enter();

        // Render tubes.
        var nodeChild = nodeChildEnter.append("rect")
                .attr("class", "nodeChild")
                .attr("x", function (d) {
                    return d.x;
                })
                .attr("y", function (d) {
                    return d.y;
                })
                .attr("width", function (d) {
                    return d.w;
                })
                .attr("height", function (d) {
                    return d.h;
                });
        nodeChildEnter.append("text")
                .attr("class", "label")
                .attr("x", function (d) {
                    return d.x;
                })
                .attr("y", function (d) {
                    return d.y;
                })
                .attr("dx", 25)
                .attr("dy", 10)
                .text(function (d) {
                    return d.name;
                })
//                .each(function (d) {
//                    var b = this.parentNode.getBBox();
//                    var extra = 2 * margin + 2 * pad;
//                    d.width = b.width + extra;
//                    d.height = b.height + extra;
//                });

        // Convert Dagre edge control points into pairs of line points.
        var links = [];
        g.edges().forEach(function(e) {
            var points = g.edge(e).points;
            for(var i=0, len=points.length-1; i<len; i++){
                // (note: loop until length - 1 since we're getting the next
                //  item with i+1)
                links.push({
                    sourceX: points[i].x,
                    sourceY: points[i].y,
                    targetX: points[i + 1].x,
                    targetY: points[i + 1].y
                });
            }
        });

        // Render edges.
        var points = svg.selectAll(".link")
                .data(links)
                .enter().append("line")
                .attr("class", "link")
                .attr("x1", function (d) {
                    return d.sourceX;
                })
                .attr("y1", function (d) {
                    return d.sourceY;
                })
                .attr("x2", function (d) {
                    return d.targetX;
                })
                .attr("y2", function (d) {
                    return d.targetY;
                });

    });
    function isIE() {
        return ((navigator.appName == 'Microsoft Internet Explorer') || ((navigator.appName == 'Netscape') &&
        (new RegExp("Trident/.*rv:([0-9]{1,}[\.0-9]{0,})").exec(navigator.userAgent) != null)));
    }
</script>
</body>
</html>